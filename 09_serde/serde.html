<!DOCTYPE html>
<html>

<head>
    <title>Custom Serialization with serde</title>
    <meta charset="utf-8">
    <style>
        @font-face {
            font-family: 'Carlito';
            src: url('../fonts/Carlito.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Carlito';
            src: url('../fonts/Carlito-Bold.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Carlito';
            src: url('../fonts/Carlito-Italic.woff2') format('woff2');
            font-weight: normal;
            font-style: italic;
        }

        @font-face {
            font-family: 'Iosevka Web';
            font-display: swap;
            font-weight: 400;
            font-stretch: normal;
            font-style: normal;
            src: url('../fonts/iosevka-regular.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Carlito';
            src: url('../fonts/Carlito-BoldItalic.woff2') format('woff2');
            font-weight: 700;
            font-style: italic;
        }

        @font-face {
            font-family: 'Bebas Neue';
            src: url('../fonts/BebasNeueRegular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Bebas Neue';
            src: url('../fonts/BebasNeueBold.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Iosevka Web';
            font-display: swap;
            font-weight: 400;
            font-stretch: normal;
            font-style: italic;
            src: url('../fonts/iosevka-italic.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Iosevka Web';
            font-display: swap;
            font-weight: 700;
            font-stretch: normal;
            font-style: normal;
            src: url('../fonts/iosevka-bold.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Iosevka Web';
            font-display: swap;
            font-weight: 700;
            font-stretch: normal;
            font-style: italic;
            src: url('../fonts/iosevka-bolditalic.woff2') format('woff2');
        }

        body {
            font-family: 'Carlito';
        }

        .remark-slide-content {
            padding: 1rem 4rem 1rem 4rem;
        }

        .middle-slide {
            font-size: 25px;
        }

        h1,
        h2,
        h3 {
            font-family: 'Carlito';
            font-weight: bold;
        }

        .remark-slide-content h1 {
            margin-top: 1rem;
            font-size: 4rem;
            margin-bottom: 2rem;
        }

        .remark-code,
        .remark-inline-code {
            font-family: 'Iosevka Web', Iosevka, monospace;
        }

        .title-slide,
        .final-slide {
            color: #000;
        }

        .title-slide .remark-slide-number,
        .final-slide .remark-slide-number {
            visibility: hidden;
        }

        .title-slide h1 {
            font-weight: bold;
            text-transform: uppercase;
            font-family: 'Bebas Neue';
            font-size: 96pt;
            margin-top: 1.5rem;
        }

        .title-slide h2 {
            font-size: 3.5rem;
            margin-bottom: 0rem;
            margin-top: 1rem;
        }

        .title-slide .author-info {
            position: absolute;
            bottom: 2rem;
            font-size: 1.5rem;
        }

        .final-slide h1 {
            margin-top: 1.5rem;
            font-size: 6rem;
        }

        li {
            margin-top: 0.5rem;
        }

        li p:first-child {
            margin-top: 0rem;
        }

        li p {
            margin-bottom: 0rem;
        }

        li pre {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .remark-slide-number {
            right: 2rem;
        }

        .footer {
            position: absolute;
            opacity: 0.5;
            bottom: 12px;
            left: 4rem;
            font-size: 1rem;
            line-height: 1.8;
            text-align: left;
        }

        .right-column {
            width: 25%;
            float: right;
            display: block;
            font-size: 0.8em;
            margin-left: 2rem;
        }

        .right-column figure {
            margin: 0rem;
        }

        .right-column img {
            max-width: 100%;
        }

        .right-column figcaption {
            font-style: italic;
            font-size: 0.8em;
            color: #555;
        }

        .right-column h3 {
            margin-bottom: 0rem;
            font-size: 1.2em;
        }

        .right-column> :first-child {
            margin-top: 0rem;
        }

        .footnotes,
        .footnotes a {
            color: #666;
        }

        .right-column ol {
            margin-top: 0.5rem;
        }

        code,
        .code {
            font-family: 'Iosevka';
        }

        .footnote {
            color: gray;
            font-size: 0.6em;
            vertical-align: super;
            position: relative;
            padding-left: 0.2rem;
            padding-top: -5rem;
        }

        .footnote::before {
            content: '['
        }

        .footnote::after {
            content: ']'
        }

        .gray {
            color: gray;
        }

        .green-border {
            border: 2px solid green;
        }

        .green-border td {
            border-left: 2px solid green;
            min-width: 3rem;
            text-align: center;
        }

        .green-border td:first-child {
            border-left: none;
        }

        .pass-data-check {
            height: .9em;
            vertical-align: -0.2rem;
        }
    </style>
</head>

<body>
    <textarea id="source">

class: title-slide

# Custom Serialization with serde

## Supporting the `ROS2` message format in Dora

<div class="author-info">
    Philipp Oppermann<br>
    os2edu<br>
    2023-11-24
</div>

---

name: middle-slide
layout: true
class: middle-slide
<div class="footer">Custom Serde (De-)Serializer, Philipp Oppermann, os2edu, 2023-11-24</div>

---


# Agenda

- Introduction to `serde` crate
    - Basic design, data types
    - Example: Deriving Serialize and Deserialize traits
    - Example: Custom Serialize implementation
    - Example: Custom Deserialize implementation
    - Advanced usage: Zero-copy
- Dynamic (De-)Serialization
   - Motivation: Bridging ROS2 and Dora → CDR format
   - Custom typed serializer for Python objects
   - Custom type deserializer → `DeserializeSeed`

---

# The `serde` crate

- Framework for serializing and deserializing Rust data structures
- Based on Rust's trait system
- Independent of data format
    - Generic data format that can represent all Rust types
    - External crates to translate `serde` data format into target format
        - E.g. for JSON, YAML, MessagePack, TOML, CSV, binary formats, etc.
- Derive macros for convenience
- Supports `no_std` environments

---

# Serde Derive Example

.right-column[

<div style="margin-top: 10rem;"></div>

Output:

```json
{
  "Line": {
    "from": {
      "x": 1,
      "y": 2
    },
    "to": {
      "x": 3,
      "y": 4
    }
  }
}
```


]

```rust
#[derive(`serde::Serialize`, `serde::Deserialize`, Debug, PartialEq, Eq)]
enum Shape {
    Point(Point),
    Line { from: Point, to: Point },
}

#[derive(`serde::Serialize`, `serde::Deserialize`, Debug, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let shape = Shape::Line {
        from: Point { x: 1, y: 2 },
        to: Point { x: 3, y: 4 },
    };

    let serialized = serde_json::to_string_pretty(&shape).unwrap();
    println!("{serialized}");
    assert_eq!(serde_json::from_str::<Shape>(&serialized).unwrap(), shape);
}
```

---

# Serde Derive Example: YAML

.right-column[

<div style="margin-top: 10rem;"></div>

**YAML Output:**

```yaml
---
Line:
  from:
    x: 1
    y: 2
  to:
    x: 3
    y: 4
```


]

```rust
#[derive(`serde::Serialize`, `serde::Deserialize`, Debug, PartialEq, Eq)]
enum Shape {
    Point(Point),
    Line { from: Point, to: Point },
}

#[derive(`serde::Serialize`, `serde::Deserialize`, Debug, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let shape = Shape::Line {
        from: Point { x: 1, y: 2 },
        to: Point { x: 3, y: 4 },
    };

    let serialized = `serde_yaml::to_string`(&shape).unwrap();
    println!("{serialized}");
    assert_eq!(`serde_yaml::from_str`::<Shape>(&serialized).unwrap(), shape);
}
```

---

# Serde Derive: Attributes

Derived `Serialize`/`Deserialize` implementations can be customized through `#[serde]` attributes, e.g.:

- Rename containers or fields:
    ```rust
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename = "GreatExample", rename_all = "camelCase")]
    struct Example {                        // struct name will be changed to `GreatExample`
        field_one: u32,                     // will be renamed to `fieldOne`
        some_other_field: u32,              // will be renamed to `someOtherField`
        #[serde(rename = "lastField")]
        field_three: bool,                  // will be renamed to `lastField`
    }
    ```
--
- Don't serialize `None` fields:
    ```rust
    #[derive(serde::Serialize, serde::Deserialize)]
    struct Example {
        `#[serde(skip_serializing_if = "Option::is_none")]`
        field: Option<u32>,
    }
    ```
---

# Serde Derive: More Attributes

.right-column[

With `flatten`:
```json
{
    "field_1": 42,
    "field_a": true,
    "field_b": "Hello"
}
```
Without `flatten`:
```json
{
    "field_1": 42,
    "field_2": {
        "field_a": true,
        "field_b": "Hello"
    }
  }
```
]


- Flatten nested structs:
    ```rust
    #[derive(serde::Serialize, serde::Deserialize)]
    struct Example {
        field_1: u32,
        `#[serde(flatten)]`
        field_2: Field2,
    }

    #[derive(serde::Serialize, serde::Deserialize)]
    struct Field2 {
        field_a: bool,
        field_b: String,
    }
    ```
--
- Fill default values on deserialization:
    ```rust
    #[derive(serde::Serialize, serde::Deserialize)]
    struct Example {
        `#[serde(default)]`
        name: String,                   // fills with empty string if not present
    }
    ```

---

# Serde Derive: Enum Representations

TODO

---

# The `Serialize` Trait

```rust
pub trait Serialize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
       where S: Serializer;
}
```

- Implemented for Rust types that can be serialized
  - maps Rust types to _serde data model_
- `Serialize` trait is independent of target format
  - generic parameter `S` allows passing in any compatible serializer
- Standard implementations can be derived
  - derive behavior can be customized through attributes
  - full manual implementation is possible too

---

# Serde Data Model

Most Rust types have corresponding types in the serde data model, e.g.:
- all primitive types, e.g. `i64`, floats, `bool`, `char`
- UTF8 strings, byte arrays, `Vec`, `HashMap`
- structs, enums, tuples

→ Serialization is often a trivial mapping

--

<hr>

`Serialize` implementations can **map to a different serde type** if desired. For example:

- `std::ffi::OsString` represents a platform-native string
    - not guaranteed to be UTF8-encoded, so serializing as serde string would be invalid
    - serialize as ASCII **byte array** on UNIX
    - serialize as **sequence of 16-bit UTF-16** values

---

# Manual `Serialize` implementation

```rust
struct Point {
    x: i32,
    y: i32,
}

impl serde::Serialize for Point {
    fn serialize<S>(&self, serializer: S,) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut s = serializer.serialize_struct(
            "Point",
            2, // number of fields
        )?;
        s.serialize_field("x", &self.x)?;
        s.serialize_field("y", &self.y)?;
        s.end()
    }
}
```

---

# Example: Change type on `Serialize`

Serialize struct as string:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl serde::Serialize for Point {
    fn serialize<S>(&self, serializer: S,) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let string_representation = format!("{}:{}", self.x, self.y);
        serializer.`serialize_str`(&string_representation)
    }
}
```


---

# The `Deserialize` Trait

TODO

TODO: manual implementation example

---

# Serde: Advanced Usage

- TODO zero copy, deserializer lifetimes

---

# Dora ROS2 Bridge

TODO

---

# CDR Format

- not self-describing
- limited Python types -> not all types are representable

TODO:
- parse ROS2 msg files
- guide serialization/deserialization by type info

---

# Type-guided Serialization

TODO

---

# Type-guided Deserialization

TODO DeserializeSeed

---

class: final-slide

# Summary

TODO

    </textarea>
    <script src="../remark-latest.min.js"></script>
    <script>
        var slideshow = remark.create({
            ratio: '16:9',
            navigation: {
                scroll: false
            },
            slideNumberFormat: '%current%',
            highlightLines: true,
            highlightSpans: true,
            countIncrementalSlides: false,
        });
    </script>
</body>

</html>
